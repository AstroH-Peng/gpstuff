%   Author: Jarno Vanhatalo <Jarno.Vanhatalo@tkk.fi>
%   Last modified: 2009-12-21 09:09:21 EET

Modifications:
- jitterSigmas is initialized to zero (used to be 1e-4)
- gpla_e uses Newton method as a default optimization for latent
  values (used to be fminunc large scale)

- Luokittelu: logit - korjaa {0,1}->{-1,1} helppiin
              demoon sama


RM-HMC toteutus ?
------------------


sinvchi2_*
---------
- gradientti pielessä





===============================================
LISÄINFOA
===============================================


------
Vaihtoehtoisten metriikoiden toteutus
------
Date: Tue, 25 Nov 2008 13:53:31 +0200 (EET)
From: Jarno Vanhatalo <jpvanhat@zeus.lce.hut.fi>
To: Aki Vehtari <Aki.Vehtari@hut.fi>
Cc: Jaakko Riihimäki <jtriihim@lce.hut.fi> Subject: Re: mallinnuksen vaiheet alustavasti

On Fri, 21 Nov 2008, Aki Vehtari wrote:

>
> Kategorisen muuttujan voisi muuten koodata myös yhdellä syötteellä
> niin, että etäisyys r
>  r(x_i,x_j)=0, jos x_i=x_j
>  r(x_i,x_j)=r_c, muuten
> missä r_c valitaan siten, että length-scale:n tulkinta a priori
> vastaava kuin binaarisilla muuttujilla. Näin esim.
> sairaanhoitopiiriefektillä olisi vain yksi relevanssia kuvaava
> hyperparametri ja ko. efekti saadaan mukavasti mukaan tavanomaisiin
> kovarianssifunktioihin. Lisääpä todo-listalle tuollainen.
> Muistakseeni Neal oli toteuttanut tämän fbm:ssä, mutta ei demonnut
> sitä, joten sen hyöty ei aikoinaan auennut.
> > Jarno voisi kommentoida, mitä vaikutusta sillä on, että osalle
> kovariaateista etäisyys lasketaan muuten kuin euklidisesti?

Mitähän yllä oleva nyt tarkoitti? Koitanpa vastata kuitenkin kysymykseen.
 Tällä hetkellä kovarianssifunktiot on aika selkeästi kovakoodattu
euklidiselle etäisyydelle. Kaikki funktiot perustuu siihe, että on kaksi
vaihtoehtoa: 1) kaikilla syötteillä sama length-scale 2) jokaisella
syötteellä oma length-scale. Varsin paljon työtä tulee aiheuttamaan jo
se, että GP-paketti muutettaisiin toimimaan siten, että voidaan määritellä
osalle syötteitä samat ja osalle omat length-scalet.

Jos halutaan, että käyttäjä voi määrittää etäisyysfunktion vapaasti,
täytyy kaikki kovarianssifunktiot koodata osittain uudestaan. Käytännössä
vapaavalintaisen etäisyyden voisi toteuttaa siten, että kovarianssifunktio
struktuurille annettaisiin kenttä (esim.) 'metrics'. Tällöin gpcf_*_trcov,
*_cov, _ghyper jne. funktioihin voisi lisätä tarkistuksen, onko
struktuurissa kyseistä kenttää. Jos kenttää ei ole, lasketaan kaikki kuten
tälläkin hetkellä. Jos kenttä on, lasketaan kaikki muuten samoin kuin nyt,
mutta etäisyys lasketaan uudella tavalla.

Esimerkiksi:

----------- clip -----------------
function C = gpcf_sexp_trcov(gpcf, x)
% GP_SEXP_TRCOV     Evaluate training covariance matrix of inputs. 
% 
%
% Description 
%         C = GP_SEXP_TRCOV(GP, TX) takes in covariance
% function of a Gaussian 
%         process GP and matrix TX that contains training input vectors.
%         Returns covariance matrix C. Every element ij of C contains
%         covariance between inputs i and j in TX
%
%
%         See also
%         GPCF_SEXP_COV, GPCF_SEXP_TRVAR, GP_COV, GP_TRCOV

if ~isfield(gpcf, 'metrics')
   % Lasketaan vanhalla tavalla

    [n, m] =size(x);

    s = 1./(gpcf.lengthScale);
    s2 = s.^2;
    if size(s)==1
        s2 = repmat(s2,1,m);
    end
    ma = gpcf.magnSigma2;

    C = zeros(n,n);
    for ii1=1:n-1
        d = zeros(n-ii1,1);
        col_ind = ii1+1:n;
        for ii2=1:m
            d = d+s2(ii2).*(x(col_ind,ii2)-x(ii1,ii2)).^2;
        end
        C(col_ind,ii1) = d;
    end
    C = C+C';
    C = ma.*exp(-C);

else
    % Lasketaan uudella tavalla
    feval(gpcf.metrics, gpcf, x)
end
----------- clip -----------------

Yllä laitoin gpcf.metrics:n funktio handleksi, koska tällöin samaa
metriikkaa voisi käyttää kätevästi muissakin kovarianssifunktioissa.

Koodien pitäisi olla sen verran modulaarisia jo nyt, että yllä olevan
tarkistuksen lisääminen taitaa onnistua kohtuu helposti. Lisään
modifioinnin TODO listaan.

-Jarno
