/* GP2FWD
 *
 * Copyright (C) 1998-2001 Aki Vehtari
 *
 * Last modified: 2003-10-24 15:45:16 EEST
 *
 */

#include <math.h>
#include "mex.h"
#define max(a,b) (((a) > (b)) ? (a) : (b))

void mexFunction(const int nlhs, mxArray *plhs[],
		 const int nrhs, const mxArray *prhs[])
{

  if (nlhs>1)
    mexErrMsgTxt( "Wrong number of output arguments.");
  
  if (nrhs<3 || nrhs>5)
    mexErrMsgTxt( "Wrong number of input arguments." );
  
  if(!mxIsStruct(prhs[0]))
    mexErrMsgTxt("First input must be a structure.");
  
  {
    const double *tx, *tx0, *ty, *x=NULL, *r, *nv, dzero=0.0, done=1.0;
    double s, es, js, ns=0, rr, *K, *kp, *C, *cp, d, *b, *y, eps;
    const int *dims, one=1;
    int i, j, k, m, n, m2, info, lr;
    char *uplo="L", *trans="N";
    mxArray *field;

    dims = mxGetDimensions(prhs[1]);
    tx = mxGetPr(prhs[1]);
    m = dims[0];
    n = dims[1];
    tx0=tx;
    
    dims = mxGetDimensions(prhs[2]);
    if (dims[0]!=m || dims[1]!=1)
      mexErrMsgTxt( "TY must be M x 1 vector." );
    ty = mxGetPr(prhs[2]);

    if (nrhs>3) {
      dims = mxGetDimensions(prhs[3]);
      if (dims[0]==0 && dims[1]==0) {
	x=NULL;
	m2=m;
      }
      else if (dims[1]!=n)
	mexErrMsgTxt( "TX and X must have same number of columns." );
      else {
	x=mxGetPr(prhs[3]);
	m2 = dims[0];
      }
    } else {
      x=NULL;
      m2=m;
    }

    if (nrhs>4) {
      dims = mxGetDimensions(prhs[4]);
      if (dims[0]!=m && dims[1]!=m)
	mexErrMsgTxt( "invC must be MxM matrix." );
      C=mxGetPr(prhs[4]);
    } else {
      C=NULL;
    }

    if((field=mxGetField(*prhs, 0, "expScale"))==NULL)
      mexErrMsgTxt("Could not get gp.expScale");
    dims = mxGetDimensions(field);
    if (dims[0]!=1 || dims[1]!=1)
      mexErrMsgTxt( "S must be a scalar." );
    s = 2*log(mxGetScalar(field));
    es=exp(s);
    
    if((field=mxGetField(*prhs, 0, "expSigmas"))==NULL)
      mexErrMsgTxt("Could not get gp.expSigmas");
    dims = mxGetDimensions(field);
    if (dims[0]!=1 && dims[1]!=1)
      mexErrMsgTxt( "R must be a scalar or a vector." );
    lr=max(dims[0],dims[1]);
    if (lr!=1 && lr!=n)
      mexErrMsgTxt("R must be scalar or length of R must same as number of columns in X.");
    r = mxGetPr(field);

    if((field=mxGetField(*prhs, 0, "jitterSigmas"))==NULL)
      mexErrMsgTxt("Could not get gp.jitterSigmas");
    dims = mxGetDimensions(field);
    if (dims[0]!=1 || dims[1]!=1)
      mexErrMsgTxt( "JS must be a scalar." );
    js = mxGetScalar(field);
    js*=js;
      
    if((field=mxGetField(*prhs, 0, "noiseVariances"))==NULL)
      mexErrMsgTxt("Could not get gp.noiseVariances");
    dims = mxGetDimensions(field);
    if (dims[0]==0 && dims[1]==0) {
      nv=NULL;
      if((field=mxGetField(*prhs, 0, "noiseSigmas"))==NULL)
	mexErrMsgTxt("Could not get gp.noiseSigmas");
      dims = mxGetDimensions(field);
      if (dims[0]==0 || dims[1]==0)
	ns=0;
      else {
	if (dims[0]!=1 || dims[1]!=1)
	  mexErrMsgTxt( "NS must be a scalar." );
	ns = mxGetScalar(field);
	ns*=ns;
      }
    } else {
      if (dims[0]!=1 && dims[1]!=1)
	mexErrMsgTxt( "NV must be a vector." );
      if (dims[1]!=m && dims[0]!=m)
	mexErrMsgTxt( "Length of NV must same as number of rows in X." );
      nv = mxGetPr(field);
    }

    plhs[0]=mxCreateDoubleMatrix(m2, 1, mxREAL);
    y = mxGetPr(plhs[0]);

    eps=mxGetEps();
    /* K */
    if (x!=NULL) {
      K=mxCalloc(m*m2,sizeof(double));
      if (lr>1) {
	for (i=0;i<n;i++,tx+=m,x+=m2) {
	  for (j=0,rr=r[i]*r[i];j<m;j++) {
	    for (k=0;k<m2;k++) {
	      d=tx[j]-x[k];
	      K[j*m2+k]+=d*d*rr;
	    }
	  }
	}
      } else {
	rr=r[0]*r[0];
	for (i=0;i<n;i++,tx+=m,x+=m2) {
	  for (j=0;j<m;j++) {
	    for (k=0;k<m2;k++) {
	      d=tx[j]-x[k];
	      K[j*m2+k]+=d*d*rr;
	    }
	  }
	}
      }
      for (j=0;j<m;j++) {
	for (k=0;k<m2;k++) {
	  d=exp(s-K[j*m2+k]);
	  K[j*m2+k]=(d>eps) ? d : 0;
	}
      }
      if (C!=NULL) {
	b=mxCalloc(m,sizeof(double));
	dsymv(uplo, &m, &done, C, &m, ty, &one, &dzero, b, &one);
 	dgemv(trans, &m, &m2, &done, K, &m, b, &one, &dzero, y, &one);
	mxFree(b);
      } else {
	x=tx0;
	C=mxCalloc((m*(m+1))/2,sizeof(double));
	if (lr>1) {
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,cp=C,rr=r[i]*r[i];j<m;j++) {
	      cp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		*cp+=d*d*rr;
		cp++;
	      }
	    }
	  }
	} else {
	  rr=r[0]*r[0];
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,cp=C;j<m;j++) {
	      cp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		*cp+=d*d*rr;
		cp++;
	      }
	    }
	  }
	}
	if (nv==NULL) {
	  for (j=0,cp=C;j<m;j++) {
	    *cp=es+js+ns;
	    cp++;
	    for (k=j+1;k<m;k++) {
	      d=exp(s-*cp);
	      *cp=(d>eps) ? d : 0;
	      cp++;
	    }
	  }
	} else {
	  for (j=0,cp=C;j<m;j++) {
	    *cp=es+js+nv[j];
	    cp++;
	    for (k=j+1;k<m;k++) {
	      d=exp(s-*cp);
	      *cp=(d>eps) ? d : 0;
	      cp++;
	    }
	  }
	}
	b=mxCalloc(m,sizeof(double));
	for (i=0;i<m;i++)
	  b[i]=ty[i];
	dpptrf(uplo, &m, C, &info);
	dpptrs(uplo, &m, &one, C, b, &m, &info);
 	dgemv(trans, &m2, &m, &done, K, &m2, b, &one, &dzero, y, &one);
	mxFree(C);
	mxFree(b);
      }
      mxFree(K);
    }  else { /* x==NULL */
      if (C!=NULL) {
	x=tx0;
	K=mxCalloc((m*(m+1))/2,sizeof(double));
	if (lr>1) {
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,kp=K,rr=r[i]*r[i];j<m;j++) {
	      kp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		*kp+=d*d*rr;
		kp++;
	      }
	    }
	  }
	} else {
	  rr=r[0]*r[0];
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,kp=K;j<m;j++) {
	      kp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		*kp+=d*d*rr;
		kp++;
	      }
	    }
	  }
	}
	for (j=0,kp=K;j<m;j++) {
	  *kp=es;
	  kp++;
	  for (k=j+1;k<m;k++) {
	    d=exp(s-*kp);
	    *kp=(d>eps) ? d : 0;
	    kp++;
	  }
	}
	b=mxCalloc(m,sizeof(double));
	dsymv(uplo, &m, &done, C, &m, ty, &one, &dzero, b, &one);
 	dspmv(uplo, &m, &done, K, b, &one, &dzero, y, &one);
	mxFree(K);
	mxFree(b);
      } else {
	x=tx0;
	C=mxCalloc((m*(m+1))/2,sizeof(double));
	K=mxCalloc((m*(m+1))/2,sizeof(double));
	if (lr>1) {
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,cp=C,kp=K,rr=r[i]*r[i];j<m;j++) {
	      cp++;
	      kp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		d*=d*rr;
		*cp+=d;
		cp++;
		*kp+=d;
		kp++;
	      }
	    }
	  }
	} else {
	  rr=r[0]*r[0];
	  for (i=0;i<n;i++,x+=m) {
	    for (j=0,cp=C,kp=K;j<m;j++) {
	      cp++;
	      kp++;
	      for (k=j+1;k<m;k++) {
		d=x[j]-x[k];
		d*=d*rr;
		*cp+=d;
		cp++;
		*kp+=d;
		kp++;
	      }
	    }
	  }
	}
	if (nv==NULL) {
	  for (j=0,cp=C,kp=K;j<m;j++) {
	    *cp=es+js+ns;
	    cp++;
	    *kp=es;
	    kp++;
	    for (k=j+1;k<m;k++) {
	      d=exp(s-*cp);
	      d=(d>eps) ? d : 0;
	      *cp=d;
	      cp++;
	      *kp=d;
	      kp++;
	    }
	  }
	} else {
	  for (j=0,cp=C,kp=K;j<m;j++) {
	    *cp=es+js+nv[j];
	    cp++;
	    *kp=es;
	    kp++;
	    for (k=j+1;k<m;k++) {
	      d=exp(s-*cp);
	      d=(d>eps) ? d : 0;
	      *cp=d;
	      cp++;
	      *kp=d;
	      kp++;
	    }
	  }
	}
	b=mxCalloc(m,sizeof(double));
	for (i=0;i<m;i++)
	  b[i]=ty[i];
	dpptrf(uplo, &m, C, &info);
	dpptrs(uplo, &m, &one, C, b, &m, &info);
 	dspmv(uplo, &m, &done, K, b, &one, &dzero, y, &one);
	mxFree(C);
	mxFree(K);
	mxFree(b);
      }
    }
  }
  
  return;
}     
